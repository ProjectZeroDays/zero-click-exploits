import tkinter as tk
from tkinter import ttk, messagebox
import os
import subprocess
import re
import shodan
import nmap
import logging
import json
import base64
from cryptography.fernet import Fernet
from tkinter.simpledialog import askstring
import requests
from project_red_sword import Chatbot

class C2Dashboard:
    def __init__(self, root):
        self.root = root
        self.root.title("C2 Dashboard")
        self.create_widgets()
        self.load_user_preferences()
        self.setup_logging()
        self.user_role = None
        self.session_active = False
        self.chatbot = Chatbot()

    def create_widgets(self):
        self.tab_control = ttk.Notebook(self.root)

        self.logs_tab = ttk.Frame(self.tab_control)
        self.exploits_tab = ttk.Frame(self.tab_control)
        self.communication_tab = ttk.Frame(self.tab_control)
        self.device_control_tab = ttk.Frame(self.tab_control)
        self.target_scanning_tab = ttk.Frame(self.tab_control)

        self.tab_control.add(self.logs_tab, text="Logs")
        self.tab_control.add(self.exploits_tab, text="Exploits")
        self.tab_control.add(self.communication_tab, text="Communication")
        self.tab_control.add(self.device_control_tab, text="Device Control")
        self.tab_control.add(self.target_scanning_tab, text="Target Scanning")

        self.tab_control.pack(expand=1, fill="both")

        self.create_logs_tab()
        self.create_exploits_tab()
        self.create_communication_tab()
        self.create_device_control_tab()
        self.create_target_scanning_tab()

    def create_logs_tab(self):
        self.logs_text = tk.Text(self.logs_tab, wrap="word")
        self.logs_text.pack(expand=1, fill="both")

        self.refresh_logs_button = ttk.Button(self.logs_tab, text="Refresh Logs", command=self.refresh_logs)
        self.refresh_logs_button.pack()

    def create_exploits_tab(self):
        self.exploits_listbox = tk.Listbox(self.exploits_tab)
        self.exploits_listbox.pack(expand=1, fill="both")

        self.load_exploits_button = ttk.Button(self.exploits_tab, text="Load Exploits", command=self.load_exploits)
        self.load_exploits_button.pack()

        self.run_exploit_button = ttk.Button(self.exploits_tab, text="Run Exploit", command=self.run_exploit)
        self.run_exploit_button.pack()

    def create_communication_tab(self):
        self.communication_text = tk.Text(self.communication_tab, wrap="word")
        self.communication_text.pack(expand=1, fill="both")

        self.send_message_button = ttk.Button(self.communication_tab, text="Send Message", command=self.send_message)
        self.send_message_button.pack()

    def create_device_control_tab(self):
        self.device_control_text = tk.Text(self.device_control_tab, wrap="word")
        self.device_control_text.pack(expand=1, fill="both")

        self.deploy_exploit_button = ttk.Button(self.device_control_tab, text="Deploy Exploit", command=self.deploy_exploit)
        self.deploy_exploit_button.pack()

    def create_target_scanning_tab(self):
        self.target_scanning_text = tk.Text(self.target_scanning_tab, wrap="word")
        self.target_scanning_text.pack(expand=1, fill="both")

        self.scan_targets_button = ttk.Button(self.target_scanning_tab, text="Scan Targets", command=self.scan_targets)
        self.scan_targets_button.pack()

    def refresh_logs(self):
        self.logs_text.delete(1.0, tk.END)
        with open("logs/deployment.log", "r") as f:
            logs = f.read()
            self.logs_text.insert(tk.END, logs)

    def load_exploits(self):
        self.exploits_listbox.delete(0, tk.END)
        exploits = os.listdir("exploits")
        for exploit in exploits:
            self.exploits_listbox.insert(tk.END, exploit)

    def run_exploit(self):
        selected_exploit = self.exploits_listbox.get(tk.ACTIVE)
        if selected_exploit:
            exploit_path = os.path.join("exploits", selected_exploit)
            result = subprocess.run([exploit_path], capture_output=True, text=True)
            messagebox.showinfo("Exploit Result", result.stdout)

    def send_message(self):
        message = self.communication_text.get(1.0, tk.END).strip()
        if message:
            # Implement secure communication logic here
            messagebox.showinfo("Message Sent", "Message sent successfully!")

    def deploy_exploit(self):
        device_info = self.device_control_text.get(1.0, tk.END).strip()
        if device_info:
            phone_regex = re.compile(r'\+?1?\d{9,15}')
            email_regex = re.compile(r'[\w\.-]+@[\w\.-]+')
            ip_port_regex = re.compile(r'(\d{1,3}\.){3}\d{1,3}:\d+')

            phone_numbers = phone_regex.findall(device_info)
            emails = email_regex.findall(device_info)
            ip_ports = ip_port_regex.findall(device_info)

            # Implement exploit deployment logic based on extracted information
            messagebox.showinfo("Exploit Deployment", "Exploits deployed successfully!")

    def scan_targets(self):
        shodan_api_key = os.getenv("SHODAN_API_KEY")
        nmap_api_key = os.getenv("NMAP_API_KEY")
        shodan_api = shodan.Shodan(shodan_api_key)
        nm = nmap.PortScanner()

        try:
            results = shodan_api.search('default password')
            for result in results['matches']:
                ip = result['ip_str']
                nm.scan(ip, '22-443')
                self.target_scanning_text.insert(tk.END, f"IP: {ip}\n")
                for proto in nm[ip].all_protocols():
                    lport = nm[ip][proto].keys()
                    for port in lport:
                        self.target_scanning_text.insert(tk.END, f"Port: {port}\tState: {nm[ip][proto][port]['state']}\n")
        except shodan.APIError as e:
            messagebox.showerror("Shodan Error", str(e))

    def setup_logging(self):
        logging.basicConfig(filename='logs/gui.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    def load_user_preferences(self):
        try:
            with open('config.json', 'r') as f:
                self.user_preferences = json.load(f)
        except FileNotFoundError:
            self.user_preferences = {}

    def save_user_preferences(self):
        with open('config.json', 'w') as f:
            json.dump(self.user_preferences, f)

    def login(self):
        username = askstring("Login", "Enter your username:")
        password = askstring("Login", "Enter your password:", show='*')
        if self.authenticate_user(username, password):
            self.user_role = self.get_user_role(username)
            self.session_active = True
            self.root.after(60000, self.check_session_timeout)
        else:
            messagebox.showerror("Login Failed", "Invalid credentials")

    def authenticate_user(self, username, password):
        # Implement user authentication logic here
        return True

    def get_user_role(self, username):
        # Implement user role retrieval logic here
        return "admin"

    def check_session_timeout(self):
        if self.session_active:
            self.session_active = False
            messagebox.showinfo("Session Timeout", "You have been logged out due to inactivity")
            self.login()

    def run_post_exploitation_module(self, module_name):
        # Implement post-exploitation module execution logic here
        messagebox.showinfo("Post-Exploitation Module", f"{module_name} executed successfully")

    def setup_ddns(self):
        no_ip_username = os.getenv("NO_IP_USERNAME")
        no_ip_password = os.getenv("NO_IP_PASSWORD")
        no_ip_hostname = os.getenv("NO_IP_HOSTNAME")

        if not no_ip_username or not no_ip_password or not no_ip_hostname:
            messagebox.showerror("DDNS Error", "No-IP DDNS credentials are missing")
            return

        update_url = f"https://{no_ip_username}:{no_ip_password}@dynupdate.no-ip.com/nic/update?hostname={no_ip_hostname}"
        response = requests.get(update_url)

        if response.status_code == 200:
            messagebox.showinfo("DDNS Update", "No-IP DDNS update successful")
        else:
            messagebox.showerror("DDNS Update", f"No-IP DDNS update failed: {response.text}")

    def setup_reverse_dns_tunneling(self):
        # Implement reverse DNS tunneling setup logic here
        pass

    def integrate_chatbot(self):
        self.chatbot_popup = tk.Toplevel(self.root)
        self.chatbot_popup.title("Chatbot")
        self.chatbot_text = tk.Text(self.chatbot_popup, wrap="word")
        self.chatbot_text.pack(expand=1, fill="both")
        self.chatbot_entry = tk.Entry(self.chatbot_popup)
        self.chatbot_entry.pack(fill="x")
        self.chatbot_entry.bind("<Return>", self.send_chatbot_command)

    def send_chatbot_command(self, event):
        command = self.chatbot_entry.get()
        if command:
            response = self.chatbot.process_command(command)
            self.chatbot_text.insert(tk.END, f"User: {command}\n")
            self.chatbot_text.insert(tk.END, f"Chatbot: {response}\n")
            self.chatbot_entry.delete(0, tk.END)

if __name__ == "__main__":
    root = tk.Tk()
    app = C2Dashboard(root)
    app.login()
    app.setup_ddns()
    app.setup_reverse_dns_tunneling()
    app.integrate_chatbot()
    root.mainloop()
