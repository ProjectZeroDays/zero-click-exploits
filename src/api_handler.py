import requests
import json
import logging
import os
from typing import Dict, Any, Optional
import schedule
import time
from datetime import datetime
from abc import ABC, abstractmethod

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Abstract Base Class for Vendor APIs
class VendorAPI(ABC):
    def __init__(self, api_name: str, api_url: str, api_key_path: str):
        self.api_name = api_name
        self.api_url = api_url
        self.api_key = self._load_api_key(api_key_path)

    @abstractmethod
    def _load_api_key(self, api_key_path: str) -> Optional[str]:
        pass

    @abstractmethod
    def call_api(self, payload: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        pass

# Concrete Class for Vendor 1 API
class Vendor1API(VendorAPI):
    def __init__(self, api_url: str = 'https://api.vendor1.com/threats', api_key_path: str = 'api-keys.json'):
        super().__init__('Vendor 1 API', api_url, api_key_path)

    def _load_api_key(self, api_key_path: str) -> Optional[str]:
        try:
            with open(api_key_path, 'r') as f:
                api_keys = json.load(f)
                return api_keys.get('vendor1_api_key')
        except FileNotFoundError:
            logging.error(f"API key file not found: {api_key_path}")
            return None
        except json.JSONDecodeError:
            logging.error(f"Error decoding JSON from API key file: {api_key_path}")
            return None

    def call_api(self, payload: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        if not self.api_key:
            logging.error("API key not loaded for Vendor 1.")
            return None
        headers = {'Authorization': f'Bearer {self.api_key}', 'Content-Type': 'application/json'}
        try:
            response = requests.post(self.api_url, headers=headers, data=json.dumps(payload))
            response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
            logging.info(f"API call to Vendor 1 successful: {response.json()}")
            return response.json()
        except requests.exceptions.RequestException as e:
            logging.error(f"Error during API call to Vendor 1: {e}")
            return None

# Concrete Class for Vendor 2 API
class Vendor2API(VendorAPI):
    def __init__(self, api_url: str = 'https://api.vendor2.com/threats', api_key_path: str = 'api-keys.json'):
        super().__init__('Vendor 2 API', api_url, api_key_path)

    def _load_api_key(self, api_key_path: str) -> Optional[str]:
        try:
            with open(api_key_path, 'r') as f:
                api_keys = json.load(f)
                return api_keys.get('vendor2_api_key')
        except FileNotFoundError:
            logging.error(f"API key file not found: {api_key_path}")
            return None
        except json.JSONDecodeError:
            logging.error(f"Error decoding JSON from API key file: {api_key_path}")
            return None

    def call_api(self, payload: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        if not self.api_key:
            logging.error("API key not loaded for Vendor 2.")
            return None
        headers = {'Authorization': f'Bearer {self.api_key}', 'Content-Type': 'application/json'}
        try:
            response = requests.post(self.api_url, headers=headers, data=json.dumps(payload))
            response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
            logging.info(f"API call to Vendor 2 successful: {response.json()}")
            return response.json()
        except requests.exceptions.RequestException as e:
            logging.error(f"Error during API call to Vendor 2: {e}")
            return None

# API Handler
class APIHandler:
    def __init__(self):
        self.vendor_apis = {
            'vendor1': Vendor1API(),
            'vendor2': Vendor2API()
        }
        self.api_queue = []

    def call_vendor_api(self, vendor_name: str, payload: Dict[str, Any]):
        """Call a vendor API with the given payload."""
        api_details = {
            'vendor_name': vendor_name,
            'payload': payload,
            'timestamp': datetime.now().isoformat()
        }
        logging.info(f"Received API call request: {api_details}")
        self.api_queue.append(api_details)
        self._process_api_call(api_details)

    def _process_api_call(self, api_details: Dict[str, Any]):
        """Process API call based on vendor name."""
        vendor_name = api_details.get('vendor_name')
        payload = api_details.get('payload')

        if vendor_name in self.vendor_apis:
            vendor_api = self.vendor_apis[vendor_name]
            response = vendor_api.call_api(payload)
            if response:
                logging.info(f"API call to {vendor_name} successful: {response}")
            else:
                logging.error(f"API call to {vendor_name} failed.")
        else:
            logging.warning(f"No API found for vendor: {vendor_name}")
            logging.info("Default API call processing completed.")

    def schedule_api_processing(self, interval_seconds: int = 60):
        """Schedule API call processing at regular intervals."""
        def job():
            logging.info("Starting scheduled API call processing...")
            if self.api_queue:
                api_call = self.api_queue.pop(0)
                self._process_api_call(api_call)
            else:
                logging.info("No API calls in queue.")
            logging.info("Scheduled API call processing completed.")

        schedule.every(interval_seconds).seconds.do(job)
        while True:
            schedule.run_pending()
            time.sleep(1)

    def load_api_keys(self, file_path: str) -> Optional[Dict[str, Any]]:
        """Load API keys from a JSON file."""
        try:
            with open(file_path, 'r') as f:
                api_keys = json.load(f)
            logging.info(f"Loaded API keys from {file_path}")
            return api_keys
        except FileNotFoundError:
            logging.error(f"API key file not found: {file_path}")
            return None
        except json.JSONDecodeError:
            logging.error(f"Error decoding JSON from {file_path}")
            return None

    def start_api_handling(self, api_key_path: str, interval_seconds: int = 60):
        """Load API keys and start API handling."""
        api_keys = self.load_api_keys(api_key_path)
        if api_keys:
            for vendor_name, vendor_api in self.vendor_apis.items():
                if isinstance(vendor_api, Vendor1API):
                    vendor_api.api_key = api_keys.get('vendor1_api_key')
                elif isinstance(vendor_api, Vendor2API):
                    vendor_api.api_key = api_keys.get('vendor2_api_key')
            self.schedule_api_processing(interval_seconds)
        else:
            logging.error("Failed to load API keys. API handling not started.")

if __name__ == '__main__':
    handler = APIHandler()
    api_key_path = 'api-keys.json'
    handler.start_api_handling(api_key_path, interval_seconds=30)
    payload = {'threat_type': 'malware', 'severity': 'high'}
    handler.call_vendor_api('vendor1', payload)
    handler.call_vendor_api('vendor2', payload)
