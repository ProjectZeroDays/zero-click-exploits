import aiohttp
import logging
import validators

logging.basicConfig(level=logging.ERROR)

class NetworkHandler:
    def __init__(self, config):
        self.config = config
        self.timeout = config['network']['timeout']
        self.retries = config['network']['retries']
        self.user_agent = config['network']['user_agent']

    async def send_request(self, url, data=None, method='GET'):
        if not validators.url(url):
            logging.error(f"Invalid URL: {url}")
            return None

        if not url.startswith("https://"):
            logging.warning(f"Using HTTP instead of HTTPS for URL: {url}")

        headers = {'User-Agent': self.user_agent}
        for attempt in range(self.retries):
            try:
                async with aiohttp.ClientSession() as session:
                    if method == 'GET':
                        async with session.get(url, timeout=self.timeout, headers=headers) as response:
                            response.raise_for_status()
                            return await self.handle_response(response)
                    elif method == 'POST':
                        async with session.post(url, data=data, timeout=self.timeout, headers=headers) as response:
                            response.raise_for_status()
                            return await self.handle_response(response)
                    elif method == 'HEAD':
                        async with session.head(url, timeout=self.timeout, headers=headers) as response:
                            response.raise_for_status()
                            return True
            except aiohttp.ClientError as e:
                logging.error(f"Error sending request to {url}, attempt {attempt + 1}: {e}")
                await asyncio.sleep(2 ** attempt)  # Exponential backoff
        logging.error(f"Failed to send request to {url} after {self.retries} attempts.")
        return None

    async def handle_response(self, response):
        content_type = response.headers.get('Content-Type', '').lower()
        if 'application/json' in content_type:
            return await response.json()
        elif 'text/html' in content_type:
            return await response.text()
        elif 'application/octet-stream' in content_type:
            return await response.read()
        else:
            logging.warning(f"Unhandled content type: {content_type}")
            return await response.text()

def create_network_handler(config):
    return NetworkHandler(config)
