from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding as sym_padding
import os
import logging
from typing import Optional, Tuple
import base64

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Key Paths
PRIVATE_KEY_PATH = "keys/private-key.pem"
PUBLIC_KEY_PATH = "keys/public-key.pem"

class EncryptionHandler:
    def __init__(self):
        self.private_key = self._load_private_key()
        self.public_key = self._load_public_key()

    def _load_private_key(self) -> Optional[rsa.RSAPrivateKey]:
        """Load the private key from file."""
        try:
            with open(PRIVATE_KEY_PATH, "rb") as key_file:
                private_key = serialization.load_pem_private_key(
                    key_file.read(),
                    password=None,
                    backend=default_backend()
                )
                logging.info("Private key loaded successfully.")
                return private_key
        except FileNotFoundError:
            logging.error(f"Private key file not found: {PRIVATE_KEY_PATH}")
            return None
        except Exception as e:
            logging.error(f"Error loading private key: {e}")
            return None

    def _load_public_key(self) -> Optional[rsa.RSAPublicKey]:
        """Load the public key from file."""
        try:
            with open(PUBLIC_KEY_PATH, "rb") as key_file:
                public_key = serialization.load_pem_public_key(
                    key_file.read(),
                    backend=default_backend()
                )
                logging.info("Public key loaded successfully.")
                return public_key
        except FileNotFoundError:
            logging.error(f"Public key file not found: {PUBLIC_KEY_PATH}")
            return None
        except Exception as e:
            logging.error(f"Error loading public key: {e}")
            return None

    def generate_symmetric_key(self) -> bytes:
        """Generate a random symmetric key."""
        return os.urandom(32)  # 256-bit key

    def encrypt_message(self, message: str) -> Optional[str]:
        """Encrypt a message using hybrid encryption (RSA for key, AES for data)."""
        if not self.public_key:
            logging.error("Public key not loaded. Encryption failed.")
            return None

        try:
            symmetric_key = self.generate_symmetric_key()
            iv = os.urandom(16)  # Initialization Vector for AES
            cipher = Cipher(algorithms.AES(symmetric_key), modes.CFB(iv), backend=default_backend())
            encryptor = cipher.encryptor()

            padder = sym_padding.PKCS7(algorithms.AES.block_size).padder()
            padded_data = padder.update(message.encode()) + padder.finalize()
            ciphertext = encryptor.update(padded_data) + encryptor.finalize()

            encrypted_key = self.public_key.encrypt(
                symmetric_key,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )
            encrypted_iv = self.public_key.encrypt(
                iv,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )
            # Combine encrypted key, IV, and ciphertext
            combined_data = base64.b64encode(encrypted_key + encrypted_iv + ciphertext).decode()
            logging.info("Message encrypted successfully.")
            return combined_data
        except Exception as e:
            logging.error(f"Error during encryption: {e}")
            return None

    def decrypt_message(self, combined_data: str) -> Optional[str]:
        """Decrypt a message using hybrid decryption (RSA for key, AES for data)."""
        if not self.private_key:
            logging.error("Private key not loaded. Decryption failed.")
            return None

        try:
            combined_data = base64.b64decode(combined_data.encode())
            encrypted_key = combined_data[:256]
            encrypted_iv = combined_data[256:512]
            ciphertext = combined_data[512:]

            symmetric_key = self.private_key.decrypt(
                encrypted_key,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )
            iv = self.private_key.decrypt(
                encrypted_iv,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )

            cipher = Cipher(algorithms.AES(symmetric_key), modes.CFB(iv), backend=default_backend())
            decryptor = cipher.decryptor()

            plaintext = decryptor.update(ciphertext) + decryptor.finalize()
            unpadder = sym_padding.PKCS7(algorithms.AES.block_size).unpadder()
            unpadded_plaintext = unpadder.update(plaintext) + unpadder.finalize()
            logging.info("Message decrypted successfully.")
            return unpadded_plaintext.decode()
        except Exception as e:
            logging.error(f"Error during decryption: {e}")
            return None

if __name__ == '__main__':
    handler = EncryptionHandler()
    message = "This is a highly sensitive message that needs to be encrypted."
    encrypted_message = handler.encrypt_message(message)
    if encrypted_message:
        print(f"Encrypted message: {encrypted_message}")
        decrypted_message = handler.decrypt_message(encrypted_message)
        if decrypted_message:
            print(f"Decrypted message: {decrypted_message}")
