import unittest
from unittest.mock import patch, AsyncMock
from src.exploit import exploit_module
from src.config import config_loader
import asyncio

class TestExploitModule(unittest.TestCase):
    def setUp(self):
        self.config = config_loader.load_config("config/config.yaml")
        self.exploit_manager = exploit_module.create_exploit_manager(self.config)

    @patch('src.exploit.exploit_module.importlib.util.spec_from_file_location')
    @patch('src.exploit.exploit_module.importlib.util.module_from_spec')
    def test_deploy_exploit_success(self, mock_module_from_spec, mock_spec_from_file_location):
        mock_spec = AsyncMock()
        mock_module = AsyncMock()
        mock_spec_from_file_location.return_value = mock_spec
        mock_module_from_spec.return_value = mock_module
        mock_module.run_exploit = AsyncMock()

        target_ip = "192.168.1.100"
        target_port = 80
        network_handler = AsyncMock()
        exploit_name = "default_exploit.py"

        asyncio.run(self.exploit_manager.deploy_exploit(exploit_name, target_ip, target_port, network_handler))

        mock_module.run_exploit.assert_called_once_with(target_ip, target_port, network_handler)

    @patch('src.exploit.exploit_module.os.path.exists')
    def test_deploy_exploit_file_not_found(self, mock_exists):
        mock_exists.return_value = False
        target_ip = "192.168.1.100"
        target_port = 80
        network_handler = AsyncMock()
        exploit_name = "non_existent_exploit.py"

        asyncio.run(self.exploit_manager.deploy_exploit(exploit_name, target_ip, target_port, network_handler))

        # Assert that the exploit was not deployed
        # You can add more specific assertions here if needed
        # For example, you could check if an error log was generated
        # or if the exploit module was not loaded.

if __name__ == '__main__':
    unittest.main()
