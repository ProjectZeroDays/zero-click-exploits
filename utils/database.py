import logging
import sqlite3
from typing import Dict, List, Optional, Any
from src.utils.helpers import setup_logging

setup_logging()

class Database:
    """
    A class for managing database operations using SQLite.
    """
    def __init__(self, db_path: str = "app.db"):
        """
        Initializes the Database class with the path to the SQLite database.

        Args:
            db_path (str, optional): The path to the SQLite database file. Defaults to "app.db".
        """
        self.db_path = db_path
        self._create_tables()

    def _create_tables(self):
        """
        Creates the necessary tables in the database if they don't exist.
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            # Create users table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    user_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT NOT NULL,
                    email TEXT NOT NULL,
                    password_hash TEXT NOT NULL,
                    role TEXT NOT NULL
                )
            """)

            # Create products table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS products (
                    product_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    description TEXT NOT NULL,
                    price REAL NOT NULL,
                    stock INTEGER NOT NULL
                )
            """)

            conn.commit()
            logging.info("Database tables created successfully.")
        except sqlite3.Error as e:
            logging.error(f"Error creating database tables: {e}")
        finally:
            if conn:
                conn.close()

    def _execute_query(self, query: str, params: tuple = ()) -> Optional[List[tuple]]:
        """
        Executes a SQL query and returns the results.

        Args:
            query (str): The SQL query to execute.
            params (tuple, optional): The parameters for the query. Defaults to ().

        Returns:
            Optional[List[tuple]]: The query results as a list of tuples, or None if an error occurs.
        """
        conn = None
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute(query, params)
            conn.commit()
            if query.lstrip().upper().startswith("SELECT"):
                return cursor.fetchall()
            return None
        except sqlite3.Error as e:
            logging.error(f"Database error: {e}")
            return None
        finally:
            if conn:
                conn.close()

    def get_user(self, user_id: int) -> Optional[Dict[str, Any]]:
        """
        Retrieves a user by their ID.

        Args:
            user_id (int): The ID of the user to retrieve.

        Returns:
            Optional[Dict[str, Any]]: The user data as a dictionary, or None if not found.
        """
        query = "SELECT user_id, username, email, role FROM users WHERE user_id = ?"
        result = self._execute_query(query, (user_id,))
        if result:
            user_id, username, email, role = result[0]
            return {"user_id": user_id, "username": username, "email": email, "role": role}
        return None

    def create_user(self, username: str, email: str, password_hash: str, role: str = "user") -> Optional[int]:
        """
        Creates a new user.

        Args:
            username (str): The username of the new user.
            email (str): The email address of the new user.
            password_hash (str): The hashed password of the new user.
            role (str, optional): The role of the new user. Defaults to "user".

        Returns:
            Optional[int]: The ID of the newly created user, or None if creation fails.
        """
        query = "INSERT INTO users (username, email, password_hash, role) VALUES (?, ?, ?, ?)"
        self._execute_query(query, (username, email, password_hash, role))
        if self._execute_query("SELECT last_insert_rowid()"):
            return self._execute_query("SELECT last_insert_rowid()")[0][0]
        return None

    def update_user(self, user_id: int, username: Optional[str] = None, email: Optional[str] = None, role: Optional[str] = None) -> bool:
        """
        Updates an existing user.

        Args:
            user_id (int): The ID of the user to update.
            username (Optional[str], optional): The new username. Defaults to None.
            email (Optional[str], optional): The new email address. Defaults to None.
            role (Optional[str], optional): The new role. Defaults to None.

        Returns:
            bool: True if the user was updated successfully, False otherwise.
        """
        query_parts = []
        params = []
        if username:
            query_parts.append("username = ?")
            params.append(username)
        if email:
            query_parts.append("email = ?")
            params.append(email)
        if role:
            query_parts.append("role = ?")
            params.append(role)

        if not query_parts:
            logging.warning("No fields to update for user.")
            return False

        query = f"UPDATE users SET {', '.join(query_parts)} WHERE user_id = ?"
        params.append(user_id)
        return self._execute_query(query, tuple(params)) is not None

    def delete_user(self, user_id: int) -> bool:
        """
        Deletes a user by their ID.

        Args:
            user_id (int): The ID of the user to delete.

        Returns:
            bool: True if the user was deleted successfully, False otherwise.
        """
        query = "DELETE FROM users WHERE user_id = ?"
        return self._execute_query(query, (user_id,)) is not None

    def list_users(self) -> List[Dict[str, Any]]:
        """
        Lists all users.

        Returns:
            List[Dict[str, Any]]: A list of dictionaries, each representing a user.
        """
        query = "SELECT user_id, username, email, role FROM users"
        result = self._execute_query(query)
        if result:
            return [{"user_id": user_id, "username": username, "email": email, "role": role} for user_id, username, email, role in result]
        return []

    def get_product(self, product_id: int) -> Optional[Dict[str, Any]]:
        """
        Retrieves a product by its ID.

        Args:
            product_id (int): The ID of the product to retrieve.

        Returns:
            Optional[Dict[str, Any]]: The product data as a dictionary, or None if not found.
        """
        query = "SELECT product_id, name, description, price, stock FROM products WHERE product_id = ?"
        result = self._execute_query(query, (product_id,))
        if result:
            product_id, name, description, price, stock = result[0]
            return {"product_id": product_id, "name": name, "description": description, "price": price, "stock": stock}
        return None

    def create_product(self, name: str, description: str, price: float, stock: int) -> Optional[int]:
        """
        Creates a new product.

        Args:
            name (str): The name of the new product.
            description (str): The description of the new product.
            price (float): The price of the new product.
            stock (int): The initial stock of the new product.

        Returns:
            Optional[int]: The ID of the newly created product, or None if creation fails.
        """
        query = "INSERT INTO products (name, description, price, stock) VALUES (?, ?, ?, ?)"
        self._execute_query(query, (name, description, price, stock))
        if self._execute_query("SELECT last_insert_rowid()"):
            return self._execute_query("SELECT last_insert_rowid()")[0][0]
        return None

    def update_product(self, product_id: int, name: Optional[str] = None, description: Optional[str] = None, price: Optional[float] = None, stock: Optional[int] = None) -> bool:
        """
        Updates an existing product.

        Args:
            product_id (int): The ID of the product to update.
            name (Optional[str], optional): The new name of the product. Defaults to None.
            description (Optional[str], optional): The new description of the product. Defaults to None.
            price (Optional[float], optional): The new price of the product. Defaults to None.
            stock (Optional[int], optional): The new stock of the product. Defaults to None.

        Returns:
            bool: True if the product was updated successfully, False otherwise.
        """
        query_parts = []
        params = []
        if name:
            query_parts.append("name = ?")
            params.append(name)
        if description:
            query_parts.append("description = ?")
            params.append(description)
        if price:
            query_parts.append("price = ?")
            params.append(price)
        if stock:
            query_parts.append("stock = ?")
            params.append(stock)

        if not query_parts:
            logging.warning("No fields to update for product.")
            return False

        query = f"UPDATE products SET {', '.join(query_parts)} WHERE product_id = ?"
        params.append(product_id)
        return self._execute_query(query, tuple(params)) is not None

    def delete_product(self, product_id: int) -> bool:
        """
        Deletes a product by its ID.

        Args:
            product_id (int): The ID of the product to delete.

        Returns:
            bool: True if the product was deleted successfully, False otherwise.
        """
        query = "DELETE FROM products WHERE product_id = ?"
        return self._execute_query(query, (product_id,)) is not None

    def list_products(self) -> List[Dict[str, Any]]:
        """
        Lists all products.

        Returns:
            List[Dict[str, Any]]: A list of dictionaries, each representing a product.
        """
        query = "SELECT product_id, name, description, price, stock FROM products"
        result = self._execute_query(query)
        if result:
            return [{"product_id": product_id, "name": name, "description": description, "price": price, "stock": stock} for product_id, name, description, price, stock in result]
        return []

if __name__ == '__main__':
    db = Database()
    # Example usage
    new_user_id = db.create_user("testuser", "test@example.com", "hashed_password", "admin")
    if new_user_id:
        retrieved_user = db.get_user(new_user_id)
        if retrieved_user:
            logging.info(f"Retrieved user: {retrieved_user}")
            db.update_user(retrieved_user["user_id"], username="updated_user")
            updated_user = db.get_user(new_user_id)
            if updated_user:
                logging.info(f"Updated user: {updated_user}")
                db.delete_user(updated_user["user_id"])
                logging.info("User deleted.")
            else:
                logging.error("Failed to update user.")
        else:
            logging.error("Failed to retrieve user.")
    else:
        logging.error("Failed to create user.")
    all_users = db.list_users()
    logging.info(f"All users: {all_users}")

    new_product_id = db.create_product("Test Product", "This is a test product.", 19.99, 100)
    if new_product_id:
        retrieved_product = db.get_product(new_product_id)
        if retrieved_product:
            logging.info(f"Retrieved product: {retrieved_product}")
            db.update_product(retrieved_product["product_id"], price=24.99)
            updated_product = db.get_product(new_product_id)
            if updated_product:
                logging.info(f"Updated product: {updated_product}")
                db.delete_product(updated_product["product_id"])
                logging.info("Product deleted.")
            else:
                logging.error("Failed to update product.")
        else:
            logging.error("Failed to retrieve product.")
    else:
        logging.error("Failed to create product.")
    all_products = db.list_products()
    logging.info(f"All products: {all_products}")
