import logging
import socket
import random
import time
from typing import Dict, Any, List
import dns.resolver
import dns.reversename
import subprocess
import os

class DNSManager:
    def __init__(self, logger: logging.Logger):
        self.logger = logger
        self.resolvers = []
        self.current_resolver = None
        self.blacklist = []
        self.whitelist = []
        self.dnssec_enabled = False
        self.https_over_dns_enabled = False

    def add_resolver(self, resolver_address: str):
        try:
            socket.inet_pton(socket.AF_INET, resolver_address)
            self.resolvers.append(resolver_address)
            self.logger.info(f"Added IPv4 resolver: {resolver_address}")
        except socket.error:
            try:
                socket.inet_pton(socket.AF_INET6, resolver_address)
                self.resolvers.append(resolver_address)
                self.logger.info(f"Added IPv6 resolver: {resolver_address}")
            except socket.error:
                self.logger.error(f"Invalid resolver address: {resolver_address}")

    def remove_resolver(self, resolver_address: str):
        if resolver_address in self.resolvers:
            self.resolvers.remove(resolver_address)
            self.logger.info(f"Removed resolver: {resolver_address}")
        else:
            self.logger.warning(f"Resolver not found: {resolver_address}")

    def get_resolvers(self) -> List[str]:
        return self.resolvers

    def set_resolver(self, resolver_address: str):
        if resolver_address in self.resolvers:
            self.current_resolver = resolver_address
            self.logger.info(f"Set current resolver to: {resolver_address}")
        else:
            self.logger.warning(f"Resolver not found: {resolver_address}")

    def clear_resolver(self):
        self.current_resolver = None
        self.logger.info("Cleared current resolver.")

    def get_current_resolver(self) -> Dict[str, str]:
        return {"address": self.current_resolver} if self.current_resolver else None

    def add_to_blacklist(self, domain: str):
        if domain not in self.blacklist:
            self.blacklist.append(domain)
            self.logger.info(f"Added to blacklist: {domain}")
        else:
            self.logger.warning(f"{domain} already in blacklist")

    def remove_from_blacklist(self, domain: str):
        if domain in self.blacklist:
            self.blacklist.remove(domain)
            self.logger.info(f"Removed from blacklist: {domain}")
        else:
            self.logger.warning(f"{domain} not in blacklist")

    def add_to_whitelist(self, domain: str):
        if domain not in self.whitelist:
            self.whitelist.append(domain)
            self.logger.info(f"Added to whitelist: {domain}")
        else:
            self.logger.warning(f"{domain} already in whitelist")

    def remove_from_whitelist(self, domain: str):
        if domain in self.whitelist:
            self.whitelist.remove(domain)
            self.logger.info(f"Removed from whitelist: {domain}")
        else:
            self.logger.warning(f"{domain} not in whitelist")

    def enable_dnssec(self):
        self.dnssec_enabled = True
        self.logger.info("DNSSEC enabled.")

    def disable_dnssec(self):
        self.dnssec_enabled = False
        self.logger.info("DNSSEC disabled.")

    def enable_https_over_dns(self):
        self.https_over_dns_enabled = True
        self.logger.info("HTTPS over DNS enabled.")

    def disable_https_over_dns(self):
        self.https_over_dns_enabled = False
        self.logger.info("HTTPS over DNS disabled.")

    def resolve_dns(self, domain: str) -> str:
        try:
            resolver = dns.resolver.Resolver()
            if self.current_resolver:
                resolver.nameservers = [self.current_resolver]
            if self.dnssec_enabled:
                resolver.use_dnssec = True
            if self.https_over_dns_enabled:
                resolver.use_https = True
            answer = resolver.resolve(domain)
            if answer and answer.rrset:
                ip_address = str(answer.rrset[0])
                self.logger.info(f"Resolved {domain} to {ip_address}")
                return ip_address
            else:
                self.logger.warning(f"DNS resolution failed for {domain}")
                return None
        except Exception as e:
            self.logger.error(f"Error resolving DNS for {domain}: {e}")
            return None

    def reverse_dns_over_https(self, ip_address: str) -> str:
        try:
            addr = dns.reversename.from_address(ip_address)
            resolver = dns.resolver.Resolver()
            if self.current_resolver:
                resolver.nameservers = [self.current_resolver]
            if self.dnssec_enabled:
                resolver.use_dnssec = True
            if self.https_over_dns_enabled:
                resolver.use_https = True
            answer = resolver.resolve(addr, 'PTR')
            if answer and answer.rrset:
                domain = str(answer.rrset[0])
                self.logger.info(f"Reverse DNS for {ip_address} is {domain}")
                return domain
            else:
                self.logger.warning(f"Reverse DNS lookup failed for {ip_address}")
                return None
        except Exception as e:
            self.logger.error(f"Error performing reverse DNS lookup: {e}")
            return None

    def reverse_ddns_tunneling(self, domain: str, data: Dict[str, Any] = None):
        self.logger.info(f"Starting reverse DDNS tunneling for {domain} - Data: {data}")
        time.sleep(random.uniform(2, 5))

    def check_sandbox_processes(self) -> bool:
        try:
            sandbox_processes = ["vboxservice", "vboxtray", "vmtoolsd", "vmwaretray", "vmwareuser"]
            for process in sandbox_processes:
                result = subprocess.run(["pgrep", process], capture_output=True, text=True)
                if result.returncode == 0:
                    self.logger.info(f"Sandbox process detected: {process}")
                    return True
            return False
        except Exception as e:
            self.logger.error(f"Error checking sandbox processes: {e}")
            return False

    def check_sandbox_files(self) -> bool:
        try:
            sandbox_files = ["/usr/bin/vboxmanage", "/usr/bin/vmware-toolbox-cmd"]
            for file in sandbox_files:
                if os.path.exists(file):
                    self.logger.info(f"Sandbox file detected: {file}")
                    return True
            return False
        except Exception as e:
            self.logger.error(f"Error checking sandbox files: {e}")
            return False

    def check_sandbox_registry_keys(self) -> bool:
        try:
            sandbox_registry_keys = [
                r"HKLM\SOFTWARE\Oracle\VirtualBox\GuestAdd\SharedFolders",
                r"HKLM\SOFTWARE\VMware, Inc.\VMware Tools"
            ]
            for key in sandbox_registry_keys:
                result = subprocess.run(["reg", "query", key], capture_output=True, text=True)
                if result.returncode == 0:
                    self.logger.info(f"Sandbox registry key detected: {key}")
                    return True
            return False
        except Exception as e:
            self.logger.error(f"Error checking sandbox registry keys: {e}")
            return False
